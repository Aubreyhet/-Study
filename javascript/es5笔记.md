[toc]
# 第一个JS程序
## 浏览器环境中，代码书写的位置:
1.直接书写自页面中的script元素中
2.书写在外部单独的js文件，然后在页面中引用[推介]
   按照引入的script文件顺序进行执行
   代码分离： 内容，样式，功能，三者分离，更加容易维护和阅读
   script标签引入外部文件 元素里边不能书写js代码
   script标签有个默认属性type 是MIME格式
## 认识基础语法
- 语法都必须是英文符号
- js由多条代码组成，代码之间用英文符号结束[并非强制要求]
- js代码从上到下依次同步执行
- js语言大小写敏感
## 认识输出语句
所有的输出语句都不是ES标准。
- document.write, 该语句用于数据输出到桌面
- alert,该语句用于将数据用弹窗的形式显示到桌面
- console.log, 该语句用于将数据打印到控制台
## 认识输入语句
所有的输入语句都不是es标准
## 认识注释
- 双斜杠 //      单行注释
- /*  */    多行注释可以换行


# 数据和数据类型
数据：有用的信息
数据类型：数据的分类
## JS中的数据和数据类型
### 原始值类型
原始类型是指不可再细分的类型

1.数字类型 number
直接可以书写
>了解：
>数字类型可以加上前缀，来表示不同的进制
>0:表示8进制
>0x:表示16进制

2.字符串类型 string
- 单引号 ''
- 双引号 ""
- 反单引号 ``  模板字符串  可以换行
在字符串中表示特殊字符

3.布尔类型 boolean
布尔类型只表示两种状态 ，非黑即白
真 true
假 false

4.undefined类型
表示未定
只有一种书写方式  ： undefined

5.null类型
表示空，不存在。
书写方式  null

>区分某些长数字和字符串，按照读法方式分辩用字符串
>手机号，身份证号 等长数子使用字符串

### 引用类型
引用类型有两种：
- 对象 Object 
可以认为，对象是由多个基本对象类型组合而成
书写对象
**属性**：对象的成员

- 函数

## 得到数据的类型
typeof 操作符
## 字面量
直接书写的具体的数据，叫做字**面量**


# 变量
## 什么是变量
变量四一块内存空间，用于保存数据
>计算机：cpu 内存  硬盘  输入输出设备
>内存：存取数据快 数据易丢失
>硬盘：存取数据慢 数据永久保存
>计算机程序的运行，仅与内存打交道
## 如何使用变量
1.声明（定义）变量
```js
var 变量名;
```
**变量声明后里边存的值是undefined**
2.给变量赋值
- 变量的值是可以变的
变量可以重新赋值，新的值覆盖旧的值
- 变量的名称
在开发中，凡是需要自行命名的位置，叫做标识符
标识符的规范：
1): 以英文字母，下划线，美元$符号开头
2): 标识符中间可以由英文字母，下划线，美元$符号，数字组成
3): 标识符应该要有语义
4): 小驼峰命名法
5): 不可以与关键字和保留词相同
- 声明和赋值合并
- **任何可以书写数据的地方都可以放变量**
- 若使用一个未声明的变量，会导致错误
- **js中存在变量提升
所有的变量都会提升到代码的最顶部 不会超越脚本块
- js中允许变量多个同名变量


# 变量和对象
原始类型：number，string，Boolean，null， undefined
引用类型：object，function
## 在变量中存放对象
1.通过对象读取属性值
```js
对象变量名.属性名
```
**当读取的属性不存在时，会得到undefined**
**当读取属性的对象不存在时，会报错**
2.通过变量，更改对象中的某个属性
**当赋值的属性不存在时会添加属性**
3.删除属性
```js
delete 对象名.属性名
对象.属性名 = undefined;
```
4.属性表达式
给属性赋值，或者读取属性时，可以使用下边的格式读取属性
```js
对象变量["属性名"]
```
- 某些属性名中包含特殊字符
实际上,js对属性名的命名要求并不严格
给属性名加上双引号
**属性的名字只能时字符串  如果是数字，将自动转换为字符串**
## 全局对象
js大部分的宿主环境，都会提供一个特殊对象，该对象可以直接在js代码中访问
，该对象叫做全局对象
在浏览器环境中，全局对象为window，表示整个窗口
全局对象中的所有属性，可以直接使用，而不需要写上全局对象名。
定义的所有全局变量  都会成为window的属性
**如果变量没有赋值，不会覆盖全局对象的同名属性**

# 引用类型
**原始变量里边放的是具体的值**
**引用类型变量存放的是内存地址**
>扩展知识：垃圾回收


# 运算符
## 操作符和操作数
操作符：运算符，参与运算的付号
操作数：参与运算的数据，也称为“元”
操作符不一定只有一个符号
操作符出现在不同的位置可能有不同的含义
## 分类
按照操作数数量区分：
1.一元运算符 ：()   .   []
2.二元运算符： + - * / % =
3.三元运算符：?:
按照功能区分：
1.算术运算符（数字）
2.逻辑运算符
3.位运算符
4.比较运算符
5.其它
## 表达式
表达式 = 操作数 + 操作符

# 算术运算符
数学运算符
1.`+ - * /`
2.`+ -`
3.`%`
4.`++ --`
5.`**`指数
## 细节
1.小数运算是不精确
2.除数为零 
如果被除数是正数，得到结果是Infinity （正无穷）
如果被除数是负数，得到结果是-Infinity（负无穷）
如果被除数是0 ，得到的结果是NaN（not a number，非数字）
isNaN  判断数据是否为NaN
inFinite  判断数据是否为有限
3.求余操作 %
## 其他类型使用算术运算符
1.除加号之外的算术运算符
boolean: true -> 1,false -> 0
string:如果字符串内部的是一个正确的数字，直接变为数字，如果是一个非数字，则得到NaN（能识别Infinity，不能把字符串内部的东西当作表达式）空字符串转换为0，会忽略前后空格
NaN虽然是数字但是与任何数据进行运算都为NaN
null: null -> 0
undefined : undefined -> NaN
将对象类型转换成字符串类型 -> "[object object]"
2.加号运算符
- 只要有一边是字符串 ，那么一定是字符串拼接
 将另外一边的类型，转换成字符串
 数字 -> 数字字符串
 布尔 -> 布尔字符串
 null -> 'null'
 - 加号两边都没有字符串，但一边有对象，将对象转换为字符串，然后按照上边的规则进行计算

 # 自增 自减
 ## 基本
 1.++ 自增一
 2.-- 自减一
 ### 自增自减表达式
 x++ 输出是加之前的值
 ++x 输出是加之后的值
 自减相同

 优先级运算细节：
 1.从左到右依次查看
 2.如果遇到操作数，将数据的值直接取出来
 3.如果遇到相邻的两个运算符，并且左边的运算符优先级大于右边的运算符，则直接运算左边的运算符
 
# 比较运算符
大小比较：< , >, <=, >=
相等运算符：==, !=, ===, !==
**比较运算符的返回类型：boolean**
**算术运算符的优先级高于比较运算符的优先级**
## 大小比较
## 细节
1.两个字符串的比较 比较的是字符串的字符编码
2.如果一个不是字符串，并且两个都是原始数据类型，将他们都转化为数字类型进行比较
NaN与任何数字比较得到的结果都是false
Infinity 比任何数字都大 反之成立
3.如果其中一个是引用类型，将对象转换为原始数据类型 再进行1，2运算
## 相等比较
###  == 普通相等比较  和 != 不等比较
**细节**
1.两边数据类型相同直接比较数据本身是否相同（两个对象比较的是对象的地址）
2.两边的数据的类型不同
1). null和undefined == 成立 相等 和其他任何数据类型比较  不相等。
2). 其他原始类型  先转换成数字再进行比较
3). NaN 与其他任何数据类型进行比较都是false 包括自己本身
4). Infiniy 和 -Infinity， 只能自身和自身相等  和其他一切偶不相等
5). 对象类型比较时 都先转化为原始类型数据进行比较
### === 严格相等比较和 !== 严格不相等
=== 严格相等比较的两边的数据类型和值必须全部相等才能成立
!== 同上
# 逻辑运算符
布尔运算符
## 与（并且）
符号：&&
书写方式：表达式1 && 表达式2
1.将表达式1进行boolean判定
以下数据均判定为false
1). null 
2). undefined 
3). false
4). NaN
5). ''
6). 0
其他的都表示为真
2.如果表达式的判定结果为假，则直接返回表达式1，而不执行表达2，否则返回表达式2的结果
## 或( || )
符号：||
书写方式：表达式1 || 表达式2
只要有一个表达式为真返回真
##非
符号：!
书写方式：!数据
一元运算符
将数据的Boolean判定结果直接取反 返回一定是boolean类型
# 三目运算符
书写方式： 表达式1 ? 表达式2 : 表达式3；
对表达式1进行Boolean判定，如果判定结果为真，返回表达式2；否则返回表达式3；

# 补充知识
## 模板字符串
'' ,  ""   ,  `` 
## 类型转换不会影响原本的数据

## 复合的赋值运算符
+= -= *= /+ **=
## void 运算符
一元运算符
1.普通写法：``` void 表达式 ```
2.函数写法：``` vold(表达式) ```
作用：运行表达式，返回undefined
## 逗号运算符
写法：表达式1,表达式2
依次执行两个表达式，返回表达式2
逗号运算符比赋值运算符优先级低

# 数字的存储
## 问题
1.js中小数运算是精确的吗？
 不一定是精确的
2.js中整数运算是精确的吗？
不一定
3.js中整数表示是连续的吗？
不是，当后边的数字很大的时候不再连续
4.js中表示最大的数是什么？
最大连续整数：
5.js中能表示的有效的位数是多少？
16~17

## 二进制
现实世界中：十进制
计算机：二进制
二进制转十进制：
1101 -> $1*2^3+1*2^2+0*2^1+1*2^0 = 13$
11.01 -> $1*2^1+1*2^0+1*2^{-1}+1*2^{-2}$ = 3.25
十进制转换二进制：
13 -> 1101
```
13 / 2  商 6  余 1
6 / 2   商 3  余 0 
3 / 2   商 1  余 1
1 / 2   商 0  余 1
```
3.25 -> 11.01
整数部分相同
```
小数部分
0.25 * 2  0.5  整数部分 0
0.5 * 2   1.0  整数部分 1
```
# 流程图
标准化的流程，用于描述程序的逻辑
通常用流程图分析程序的流程
```mermaid
graph TD
st((开始))
if{p}
```
# if 
```js
if(条件1){
   //代码块
}else if(条件2){
   //代码快
}else{
   //代码块
}
```
# switch 用法
写法：
```js
switch(表达式)
   case 数据1:
      表达式
   break
   case 数据2:
      表达式
   break
   default:
      代码块
```
表达式的值依次与case后边的数据进行全等比较，如果相等执行后边的表达式，添加关键字break 可以跳出当前计算步骤后边的代码将不会执行
default可以省略

# 循环
for循环， while循环， do-while循环
## while 循环
```js
while(条件){
   代码块(循环体)
}
```
```mermaid
graph TD
st((开始))-->条件{条件}
条件--true-->代码块
代码块-->条件
条件--false-->en((结束))
```
如果条件永远成立  或者为true  循环进入死循环

## do-while
至少循环一次循环体
```js
do{
   代码块
}while(条件)
```
```mermaid
graph TD
st((开始))-->代码块
代码块-->条件{条件}
条件--false-->代码块
条件--true-->en((结束))
```

## for循环
```js
for(初始化表达式；条件；条件改变表达式){
   循环体
}
```
```mermaid
graph TD
st((开始))-->初始化表达式
初始化表达式-->条件{条件}
条件--true-->循环体
循环体-->条件改变表达式
条件改变表达式-->条件
条件--false-->ed((结束))
```
## 循环控制语句
1.break 当前循环结束后 跳出循环体 循环结束
2.continue 跳过当前循环 继续后边的循环体

## 循环应用
### 累计问题
将1-100 的数字累加
### 查找问题
135到145是否存在能整除26的数字
### 嵌套循环

# 数组
## 创建
1.new Array(长度)
长度：非负整数，表示数据的数量
new Array(数据1，数据2，数据3...)；
创建一个数组并初始化每一项的值
数组项：数组中其中一项数据
2.[数据1，数据2，数据3...]
创建一个数组并初始化每一项数据
## 数组本质
对象
length 属性 数组长度
数字字符串属性：下标，索引，数组中每个数据的编号
不要给length赋值
数组下标不连续的叫做稀松数组
## 数组的常见操作
1.向数组末尾添加数据
数组[数组.length]=数据
数组.push(数据)    可以添加多个数据
2.向数组的开头位置添加数据
数组.unshift(数据)   会改变数组里边数据下标索引    看可以添加多个数据
3.中间添加数据
数组.splice(要添加数据的位置下标，0，要添加的数据)  ===》》  从指定位置开始，删掉0个数据，添加n个需要添加的数据
4.删除数据
delete 数组[下标] 这种做法不会影响数组长度  产生稀松数组
数组.pop() 删除数组最后一项，返回已删除的数据
数组.shift() 删除数组第一项，返回被删除的数据，删除不影响数组下标
数组.splice(要操作开始的下标，要删除的数据数量，添加新的数量（可选）)
5.其他操作
数组.slice(起始位置，结束位置)  将从起始位置到结束位置截取  得到新数组  不会影响原数组
数组清空
数组.splice(0,数组.length)  从数组第0个下标数据开始删到最后一个  清空
6.查找某一项的下标
arr.indexOf(数据)  使用严格模式查找，查到到第一个符合的返回数据的下标
arr.lastIndexOf(数据)  使用严格模式查找，查到到最后一个符合的返回数据的下标
## 语法补充
in关键字  判断某个属性在对象中是否存在
属性名 in 对象  在数组中查找的是下标和属性名
## for-in 循环
```js
for(var prop in obj){
   //代码块
}
```
取出对象所有属性名，每次循环将属性名赋值给变量prop  进行循环操作
arr.fill(填充内容，开始位置index（可选），结束下标（可选）)   从数组下标index开始到数组结尾填充内容

将数组中的每一项进行字符串拼接
arr.join('分隔符')；返回一个字符串

拼接数组
newarr = arr1.concat(arr2);
返回一个新数组  对原数组1和数组2 没有影响


# 函数
重复代码：程序难以维护
函数主要用于减少重复代码
## 创建函数
```js
function 函数名(参数){
   函数体
   }
```
函数不会自动执行必须 手动调用函数

## 调用函数
```js
函数名()
```
通过字面量声明的函数 会提升到脚本块的顶部
通过字面量声明的函数，会成为全局对象的属性

## 其他特征
通过typeof关键字，得到的结果是function
函数内部声明的变量，在函数外部是访问不到的

函数内部声明变量
1.不使用var关键字声明变量，声明的变量会在全局访问到（全局变量污染）
2.使用var关键字哎函数内部声明变量，此变量只在函数内部可以访问  在函数外部不能访问（推介）
**函数中声明的变量只能在函数内部使用，在函数外部不能使用**

## 参数
参数是函数运行的未知条件需要调用者告知的数据
如果实参没有传递，则对应的形参值为undefined

## 返回值
函数运行时得到的结果，调用函数时调用表达式的值就是函数的返回值

# 作用域和闭包
## 作用域
1.全局作用域
在全局中声明的变量，会被提升到脚本的顶部，并且会成为全局对象的属性
2.局部作用域
在函数中声明的变量，会被提升到函数内部的顶部，不会成为全局对象的属性，因此在函数内部声明的变量不会污染全局作用域
但是，当一个函数成为一个表达式时，不会提升也不会污染全局对象
将函数变为函数表达式的办法之一，将函数用户小括号括起来  **立即执行函数IIFE**
函数可以省略函数名 匿名函数
## 作用域中可以使用的变量
全局作用域中只能使用全局作用域中的变量
函数作用域中可以使用函数内部变量也可以使用函数外部作用域中的变量
当某个函数的功能比较复杂
## 闭包
闭包时一种现象
内部函数可以使用外部函数环境的变量
# 函数表达式和this
## 函数表达式
函数也是数据类型，函数可以用于任何需要数据的地方
函数表达式就是函数本身 可以把函数名省略
函数也是一个引用类型

## this关键字
在全局环境中 this指向全局对象
在函数作用域中this指向取决于是如何调用
1.如果函数直接调用  this指向全局对象
2.通过一个对象调用函数 --> 这是this指向对象

# 构造函数
## 用于创建对象的函数
用函数创建对象，可以减少繁琐的对象创建流程
1.函数返回一个对象
2.使用构造函数
1)构造函数的首字母一般大写
构造函数会创建一个新的对象，this指向新创建的对象，并且自动返回新对象
构造函数如果出现返回值，如果返回的是原始类型的数据直接忽略，如果返回的是引用类型  返回引用的数据
所有的对象都是构造函数创建的

## new target
该表达式在函数中使用返回的是当前的构造函数，但是如果不是new创建的对象 使用该表达式返回undefined

# 函数的本质
函数的本质就是对象
> 某些教程中，将构造函数称之为构造器
> 所有的对象都是通过关键字new出来的
```
new 构造函数()
```
```js
let boj = {
   x: 2,
   y: 24
}
let obj = new object();
obj.x = 2;
obj.y = 24;
 let arr = [1,2,3,4,5];
 let arr1 = new Array(4);

```

所有的函数  都是通过```new Function```创建的
由于函数本身就是对象，因此函数中，可以拥有各种属性
## 包装类
js为了增强原始类型的功能，为Boolean string number分别创建了一个构造函数
1.Boolean
2.string
3.number
如果语法上将原始类型当作对象使用时，js会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性

# 递归
函数直接或者间接调用自身
## 执行栈
任何代码的执行都需要一个运行环境，执行环境为代码的执行模式提供支持
执行环境是放到执行栈中的
每个函数的调用都需要一个一个函数的执行环境，函数调用结束，执行环境销毁
执行栈有相对固定的大小

# 标准库（标准API）
- 库：  library
- API： 应用程序编程调用接口 Application programming interface
- 标准 ：ECMScript标准
## Object
### 静态成员
keys(某对象)得到某个对象所有属性名数组
values(某对象)得到某个对象所有属性值数组
entires(某对象)得到对象属性值和属性值数组
### 实例成员
>实例成员可以被重写
**只要是对象 都拥有object的所有实例成员**
- toString()得到某个对象的字符串格式
默认情况下返回[object，object]
- valueOf() 得到某个对象的值
默认情况返回对象本身
>在js中在自动类型转换中，如果要对一个对象进行转换，先将该对象调用valueOf方法，然后再调用toString方法，进行进一步转化
## Function
**所有函数都有Function中的所有实例成员**
### 实例成员
- lenght 
- apply方法：调用方法 同时指定函数中的this指向 传参用数组的形式
- call方法：调用方法，同时指定函数中的this指向 传参直接传进去
- bind方法：绑定this指向不会调用方法，返回一个this指向被绑定的方法的新方法 可以调用多次


# Array构造器
凡是通过Array构造函数创建的对象都是数组
## 静态成员
- from()方法：将一个伪数组转换为真数组
- isArray()方法:判断给定的数组是不是真数组,返回布尔值
- of()方法:类似于中括号创建数组,依次赋予数组成员
## 实例成员
- fill()方法:用某个数据填充数组
- pop
- push
- reverse()方法:颠倒数组顺序
- shift
- sort()方法: 对数组排序
- splice()方法: 删除
- unshift()方法:删除
纯函数(不会导致当前对象)
- concat()方法:组合数组得到新数组
- includes()方法:判断当前数组是否包含指定的值,返回布尔
- join()
- slice():抽出
- indexOf():查找第一次出现的下标
- lastIndexOf:查找最后一次出现的下标
- forEach()方法: 遍历 参数为函数
- every()方法: 是否所有的元素都满足条件 参数为函数
- some()方法: 只要有一个满足条件返回true 参数为函数
- filter()方法: 返回一个满足条件的元素组成的新数组  (过滤) 参数为函数
- find()方法: 查找第一个满足条件的元素  返回元素本身 如果没有找到返回undefined
- findIndex()方法: 查找第一个满足条件的元素,返回元素的下标
- map()方法: 映射 将数组的没一项映射为另外一项 参数为函数 
- reduce方法: 统计


# 原始类型包装器
new 包装器(值)  返回的是一个对象
包装器(值)  返回的是一个原始类型数据
## number
### 静态成员
- isNaN(): 判断数据是否为NaN
- isFinite(): 判断是否为有穷数
- isInteger(): 判断是否为整数
- parseFloat(): 将一个数据转换为小数
- parInt(): 将一个数据转换为整数  直接舍去小数部分 第二个参数 识别为多少进制的数据
# 实例成员
- toFixed()方法:会四舍五入
- toPrecision()方法：以指定的精度返回一个数字字符串
## boolean
## string
### 静态成员
- fromCharCode(): 通过unicode编码创建字符串
### 实例成员
- lenght(): 字符串长度
- charAt(): 返回指定位置的字符
- charCodeAt(): 返回指定位置的字符的Unicode值
- concat(): 连接两个文本 返回一个新的文本，可以拼接多个字符串
- includes(): 查找是否存在某字符
- endsWith(): 判断字符串以某个字符串结尾
- startWinth(): 是否以某个字符开始
- indexOf(): 返回指定字符在字符串中的索引
- lastIndexOf(): 最后一次出现的索引
- padStart(): 在字符串首部填充指定字符，填充到满足指定长度（两个参数，第一个参数 指定长度，第二个参数 指定填充的字符串）
- padEnd(): 在字符串末尾填充指定字符串，填充到满足指定长度（两个参数，第一个参数 指定长度，第二个参数 指定填充的字符串）
- repeat(): 返回重复指定次数的由元素组成的新字符串对象
- slice(): 摘取字符串一段区域返回新的字符串 参数可以是负数
- substr(): 摘取字符串  从指定位置截取指定长度的字符串    参数可以为负数
- substring(): 摘取字符串  从指定位置截取到指定位置的字符串  参数不可以为负数   参数位置可以调换
- toLowerCase(): 将字符串转换为小写
- toUpperCase(): 将字符床转换为大写
- trim()：省略字符串前后空格
- splice(): 分割字符串  
字符串是伪数组

# Math对象
提供了一系列关于数学相关的成员
- random(): 产生0-1随机数
- PI：圆周率
- abs(): 求绝对值
- floor(): 对一个数进行向下取整
- ceil(): 对一个数进行向上取整
- max(): 对一个数组取最大值
- min(): 对一个数组取最小值
- pow(): 求某个数的次幂
- round(): 得到一个数的四舍五入后的数

# Date构造函数
## 创建时间对象
- 直接调用函数  返回时间字符串  不推介使用
- new Date(): 创建日期对象
 1.不加参数，返回当前时间
 2.一个数字参数表示传入的是时间戳
 3.两个及以上参数 分别是 年月日 时分秒 毫秒  月时从0开始的  如果缺失参数  后边为0
 月日十分秒毫秒 均可以传入负数  如果传入负数 就从指定日期进行计算
## 实例成员
 get 
- getDate():得到日期部分   对应 getUTCDate()：得到UTC时区时间
- getDay():得到星期几（0-6）
- getFullYear(): 得到四位数的年份
- getHours():得到当前时间小时部分
- getMinutes(): 得到当前时间的分钟部分
- getSceonds(): 得到当前时间秒部分
- getMillisceonds() :得到当前时间的毫秒部分
- getTime(): 得到时间戳
- getMonth(): 得到月 从0开始的
set 
- setDate():设置天
- setMonth(): 设置月
- setFullYear(): 设置年
- setMinutes(): 设置分钟
- setSceonds(): 设置秒
- setMillisceonds(): 设置毫秒
- setTime(): 设置时间

- toDateString(): 将日期转换为可以阅读的字符串
- toLocaleDateString(): 根据当前系统将时间转换为可读的字符串
- toLocaleString(): 根据当前的时区设置，将整个时间对象转换为可读的字符串
- toLocaleTimeString(): 根据当前的时区设置时间将时间对象转换为可读的字符串
- toString(): 将时间对象转换为和UTC一样的时间格式

## 日期的运算
date对象重写了object的valueOf方法 返回的时数字 表示时间戳
日期对象可以进行数学运算



# 正则表达式
跨语言（国际标准）
正则表达式时一个规则  验证一个字符串
## 基础
1.字面量匹配
规则中直接书写字面量字符
2.特殊字符
```
. 表示除了换行符都可以匹配
^ 匹配字符串的开始
$ 表示匹配字符串的末尾
```
3.转义符
```
\n 匹配换行符 
\r 匹配回车符
\t 匹配制表符
\s 匹配空白字符
\S 匹配除了空白字符的所有
\b 匹配字符边界
\B 非字符边界
\d 匹配一个数字字符
\D 匹配非数字
\w 匹数字字母下划线
\u unicode编码
```
转义符可以转译特殊字符
4.字符集
```
[字符范围]
```
匹配中文: ```4e00-9fa5```
5.量词
前边规则出现的次数
```
* 0次或者多次
+ 匹配一个或者多个
? 匹配0个或者1个
{n} 匹配n个
{n,} 匹配至少n个
{n,m} 匹配n到m个
```
6.或者
多个规则之间适用
```|```,表示多个规则任意一个
## js中的应用
js中正则表达式表现为一个对象，是由构造函数RegExp
### 创建正则表达式
1.字面量模式
2.构造函数模式
### 正则实例成员
- global 是否打开全局匹配
- source 表示目前的规则
- test(): 方法 验证某个字符串是否满足规则 在开启全局匹配模式下  需要注意lastIndex 不是每一次都是从字符串0开始的
- exec(): 方法 执行匹配得到匹配结果  得到一个真数组 匹配不到 返回null    

> 正则表达式默认情况下  使用的是贪婪匹配模式
> 在两次的后边加上? 进入非贪婪模式
### 字符串中的正则方法
- macth(): 方法  字符串匹配规则  在全局匹配模式下 返回匹配到的结果 以数组的形式  在非全局模式下 返回的结果和上边exec()方法返回
结果一样  
- search(): 在字符串中搜索满足条件的第一个的下标
- splice(): 以某种符号进行分割字符串 里边的参数是正则表达式 str.splice(/[, \-\s]/)
- replace(): 替换字符串 返回新的字符串  两个参数 第一个参数是被替换的字符 可以是正则表达式  第二个参数是要换成的字符 或者也可以是一个函数

## 进阶
### 捕获组
用小括号包裹的部分为捕获组 捕获组会出现在匹配结果中
捕获组可以命名叫做具名捕获组
非捕获组


# web api概述
ECMAscript标准
浏览器宿主环境（webapi）


# 获取dom节点对象
## 旧的获取dom节点

dom 0
- document.body 获取body元素节点
- document.head 获取head元素节点
- document.links 获取文档所有连接节点  是一个类数组
- document.anchors 获取页面上所有的锚连接（具有name属性）
- document.forms:获取页面上所有form元素节点

## 新的dom获取节点方式
- document.getElementById:获取文档中具有该id的元素 唯一
- document.getElementsByTagName: 通过元素名称获取dom元素  类数组
- document.getElementsByClassName: 通过类名称获取dom元素 类数组 ie9及以上
- document.getElementsByName: 通过元素的name属性获取元素节点
- document.querySelector: 通过css选择器获取dom元素 得到一个 ie8 及以上
- document.querySelectorAll: 通过css选择器获取所有符合条件的dom节点  ie8及以上 类数组 静态的
细节：
1.所有获取类数组的方法中除了querySelectorAll得到的数组是静态的其他的都死动态更新的
2.getElementById 执行效率最高
3.书写了id的元素 会自动成为window属性  他是实时的单对象 
4.getElementsByTagName,getElementsByClassName,querySelector,querySelectorAll 可以作为其他节点对象的方法使用 
### 根据节点关系获取节点
- parentNade: 获取该节点的父节点
- firstChild: 获取该节点的第一个子节点
- lastChild: 获取该节点的最后一个子节点
- nextSibling: 获取该节点的弟弟元素
- previousSibling: 获取该节点的哥哥节点
- childNode:获取所有子节点
- attribues: 获取某个元素的属性节点
### 获取元素节点
- parentElemtent: 获取父元素
- previousElementSibling: 获取上一个兄弟元素
- nextElementSibling: 获取下一个兄弟元素
- children: 获取子元素
- firstElementChild: 获取第一个子元素
- lastElementChild: 获取最后一个子元素
### 获取节点信息
- nodeName: 获取节点名称
- nodeValue: 获取节点的值
- nodeType: 节点类型  是一个数字




























